#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""

--Channel Allocation for EEG, EMG, LFP
If you want to set a specific EEG channel as EEG.mat 
(and it's not the first 'e' in the allocation string), then use capital E, M, or L.
If all e's, m's, or l's are lower- or uppper-case, the first e,m,l will be used as primary
EEG, EMG, LFP
For example, emEm, will use the second EEG for EEG.mat, and will use the first EMG as EMG.mat

--Notes
For the notes (generated by the intan system), I assume the following syntax:
Notes start with the following string:
#Notes:
(followed by newline)
Individual notes start with //
To designate a note to a specific mouse use '@MOUSE_ID'.
For example, the note
//@S10 sleeping well today
will be assigned to mouse S10. But the note
//lights problems today
will go to all recorded mice 

@author: FW

"""
import sys
import re
import os.path
import numpy as np
import scipy.io as so
import tkFileDialog as tkf
import Tkinter as Tk
from shutil import copy2, rmtree
import pdb
import h5py
import pdb
from sleepy import recursive_spectrogram
from sleepy import get_infoparam as get_infoparam2
# to do: copy video file, process video file, time.dat
# Channel allocation
# introduce colleague field and port number




def recursive_sleepstate_rem(ppath, recordings, sf=0.3, alpha=0.3, past_mu=0.2, std_thdelta = 1.5, past_len=120, sdt=2.5, psave=False, xemg=False):
    """
    predict a REM period only based on EEG/EMG history; the same algorithm is also used for 
    closed-loop REM sleep manipulation.
    The algorithm uses for REM sleep detection a threshold on delta power, EMG power, and theta/delta power.
    For theta/delta I use two thresholds: A hard (larger) threshold and a soft (lower) threshold. Initially,
    theta/delta has to cross the hard threshold to initiate a REM period. Then, as long as,
    theta/delta is above the soft threshold (and EMG power stays low) REM sleep continues.
    
    @Parameters:
        ppath        base folder with recordings
        recordings   list of recordings
        sf           smoothing factor for each spectrogram
        past_mu      percentage (0 .. 1) of brain states that are allowed to have EMG power larger than threshold
                     during the last $past_len seconds
        past_len     window to calculate $past_mu
        std_thdelta  the hard theta/delta threshold is given by, mean(theta/delta) + $std_thdelta * std(theta/delta)  
        sdt          time bin for brain sttate, typically 2.5s
        psave        if True, save threshold parameters to file.
    
    """        
    idf = re.split('_', recordings[0])[0]

    cfile = os.path.join(ppath, idf + '_rem.txt')
    if not(os.path.isfile(cfile)):

        past_len = int(np.round(past_len/sdt))
        
        # calculate spectrogram
        (SE, SM) = ([],[])
        for rec in recordings:
            A,B, freq = recursive_spectrogram(ppath, rec, sf=sf, alpha=alpha, pplot = False)       
            SE.append(A)
            SM.append(B)
            
        # fuse lists SE and SM
        SE = np.squeeze(reduce(lambda x,y: np.concatenate((x,y)), SE))
        if not(xemg):
            SM = np.squeeze(reduce(lambda x,y: np.concatenate((x,y)), SM))
        else:
            SM = SE

        # EEG, EMG bands
        ntbins = SE.shape[1]
        r_delta = [0.5, 4]
        r_theta = [5,12]
        # EMG band
        r_mu = [300, 500]

        i_delta = np.where((freq >= r_delta[0]) & (freq <= r_delta[1]))[0]
        i_theta = np.where((freq >= r_theta[0]) & (freq <= r_theta[1]))[0]
        i_mu    = np.where((freq >= r_mu[0]) & (freq <= r_mu[1]))[0]
        
        pow_delta = np.sum(SE[i_delta,:], axis=0)
        pow_theta = np.sum(SE[i_theta,:], axis=0)
        pow_mu = np.sum(SM[i_mu,:], axis=0)
        # theta/delta
        with np.warnings.catch_warnings():
            np.warnings.filterwarnings('ignore', r'invalid value encountered in divide')
            th_delta = np.divide(pow_theta, pow_delta)
        thr_th_delta1 = np.nanmean(th_delta) + std_thdelta*np.nanstd(th_delta)
        thr_th_delta2 = np.nanmean(th_delta) +  0.0*np.nanstd(th_delta)
        thr_delta = pow_delta.mean()
        thr_mu = pow_mu.mean() + 0.5*np.nanstd(pow_mu)


        ### The actual algorithm for REM detection
        rem_idx = np.zeros((ntbins,))
        prem = 0 # whether or not we are in REM
        for i in range(ntbins):
            
            if prem == 0 and pow_delta[i] < thr_delta and pow_mu[i] < thr_mu:
                ### could be REM
                
                if th_delta[i] > thr_th_delta1:
                    ### we are potentially entering REM
                    if (i - past_len) >= 0:
                        sstart = i-past_len
                    else:
                        sstart = 0
                    # count the percentage of brainstate bins with elevated EMG power
                    c_mu = np.sum( np.where(pow_mu[sstart:i]>thr_mu)[0] ) / past_len
                   
                    if c_mu < past_mu:
                        ### we are in REM
                        prem = 1  # turn laser on
                        rem_idx[i] = 1
            
            # We are currently in REM; do we stay there?
            if prem == 1:
                ### REM continues, if theta/delta is larger than soft threshold and if there's
                ### no EMG activation
                if (th_delta[i] > thr_th_delta2) and (pow_mu[i] < thr_mu):
                    rem_idx[i] = 1
                else:
                    prem = 0 #turn laser off

        # Determine which channel is EEG, EMG
        ch_alloc = get_infoparam2(os.path.join(ppath, recordings[0], 'info.txt'),  'ch_alloc')[0]
          
        # plot the whole stuff:
        # (1) spectrogram
        # (2) EMG Power
        # (3) Delta
        # (4) TH_Delta
        # plt.figure()
        # t = np.arange(0, sdt*(ntbins-1)+sdt/2.0, sdt)
        # ax1 = plt.subplot(411)
        # im = np.where((freq>=0) & (freq<=30))[0]
        # med = np.median(SE.max(axis=0))
        # ax1.imshow(np.flipud(SE[im,:]), vmin=0, vmax=med*2)
        # plt.yticks(range(0, 31, 10), range(30, -1, -10))
        # plt.ylabel('Freq. (Hz)')
        # plt.axis('tight')

        # ax2 = plt.subplot(412)
        # ax2.plot(t, pow_mu, color='black')
        # ax2.plot(t, np.ones((len(t),))*thr_mu, color='red')
        # plt.ylabel('EMG Pow.')
        # plt.xlim((t[0], t[-1]))

        # ax3 = plt.subplot(413, sharex=ax2)
        # ax3.plot(t, pow_delta, color='black')
        # ax3.plot(t, np.ones((len(t),))*thr_delta, color='red')
        # plt.ylabel('Delta Pow.')
        # plt.xlim((t[0], t[-1]))

        # ax4 = plt.subplot(414, sharex=ax3)
        # ax4.plot(t, th_delta, color='black')
        # ax4.plot(t, np.ones((len(t),))*thr_th_delta1, color='red')
        # ax4.plot(t, np.ones((len(t),))*thr_th_delta2, color='pink')
        # ax4.plot(t, rem_idx*thr_th_delta1, color='blue')
        # plt.ylabel('Theta/Delta')
        # plt.xlabel('Time (s)')
        # plt.xlim((t[0], t[-1]))
        # plt.show(block=False)
        
        # write config file
        if psave:
            cfile = os.path.join(ppath, idf + '_rem.txt')
            fid = open(cfile, 'w')
            fid.write(('IDF: %s'+os.linesep) % idf)
            fid.write(('ch_alloc: %s'+os.linesep) % ch_alloc)
            fid.write(('THR_DELTA: %.2f'+os.linesep) % thr_delta)
            fid.write(('THR_MU: %.2f'+os.linesep) % thr_mu)
            fid.write(('THR_TH_DELTA: %.2f %.2f'+os.linesep) % (thr_th_delta1, thr_th_delta2))
            fid.write(('STD_THDELTA: %.2f'+os.linesep) % std_thdelta)
            fid.write(('PAST_MU: %.2f'+os.linesep) % past_mu)
            fid.write(('SF: %.2f'+os.linesep) % sf)
            fid.write(('ALPHA: %.2f'+os.linesep) % alpha)
            fid.write(('Bern: %.2f' + os.linesep) % 0.5)
            if xemg:
                fid.write(('XEMG: %d'+os.linesep) % 1)
            else:
                fid.write(('XEMG: %d' + os.linesep) % 0)
            fid.close()
            print 'wrote file %s' % cfile

    else:
        print 'rem info already exists for %s' % idf


def get_infoparam(ppath, name):
    """
    name is a parameter/info text file, saving parameter values using the following
    syntax:
    field:   value 
    
    in regular expression:
    [\D\d]+:\s+.+    
    
    The function return the value for the given string field
    """
    fid = open(os.path.join(ppath, name), 'rU')    
    lines = fid.readlines()
    params = {}
    in_note = False
    fid.close()
    for l in lines :
        if re.search("^#[nN]otes:(.*)", l):
            #a = re.search("^#\s*(.*)", l)
            #params['note'] = [a.group(1)]
            #continue
            in_note = True
            params['note'] = []
            continue
        if in_note == True:
            if re.match("^[A-z_]+:", l):
                in_note=False
             
            if in_note and not(re.search("^\s+$", l)):
                params['note'].append(l)
        if re.search("^\s+$", l):
            continue
        if re.search("^[A-z_]+:" ,l):
            a = re.search("^(.+):" + "\s+(.*$)", l)
            if a :
                v = a.group(2).rstrip()
                v = re.split('\s+', v)
                params[a.group(1)] = v    
      
    # further process 'note' entry
    tmp = [i.strip() for i in params['note']]
    tmp = [i + ' ' for i in tmp]    
    if len(tmp)>0:
        f = lambda x,y: x+y
        tmp = reduce(f, tmp)
        tmp = re.split('//', tmp)
        tmp = ['#'+i for i in tmp if len(i)>0]

    #tmp = os.linesep.join(tmp)    
    params['note'] = assign_notes(params, tmp)
            
    return params


def assign_notes(params, notes):
    """
    check for each comment whether it was assigned to a specific mouse/mice using the 
    @ special sign; or (if not) assign it to all mice
    """
    comment = {} 
    
    mice = params['mouse_ID']
    for m in mice:
        comment[m] = []
    
    #notes = params['note']
    for l in notes:
        if re.match('@', l):
            for m in mice:
                if re.match('@' + m, l):
                    comment[m].append(l)
        else:
            comment[m].append(l)
                            
    #params['note'] = comment
    return comment


def file_time(filename):
    """
    get time stamp of file; 
    @RETURN:
        string of the format month+day+year, month, day and year each allocated 
        only two chars
    """
    import datetime
    t = os.path.getmtime(filename)
    d = datetime.datetime.fromtimestamp(t)
    day = str(d.day)
    month = str(d.month)
    year = str(d.year)
    
    if len(day) < 2:
        day = '0' + day
    if len(month) < 2:
        month = '0' + month
    year = year[2:]
        
    return month+day+year
    


def get_param_file(ppath):
    """
    get the parameter file, i.e. the only .txt file within the specified
    folder $ppath
    """
    
    files = [f for f in os.listdir(ppath) if re.search('\.txt$', f)]
    if len(files)>1:
        print("Error more than one .txt files in specified folder %s" % ppath)
        sys.exit(1)
    if len(files) == 0:
        print("Error no parameter file in specified folder %s" % ppath)
    else:
        return files[0]
    


def get_lowest_filenum(path, fname_base):
    """
    I assume that path contains files/folders with the name fname_base\d+
    find the file/folder with the highest number i at the end and then 
    return the filename fname_base(i+1)
    """
    files = [f for f in os.listdir(path) if re.match(fname_base, f)]
    l = []
    for f in files :
        a = re.search('^' + fname_base + "(\d+)", f)
        if a :
            l.append(int(a.group(1)))           
    if l: 
        n = max(l) + 1
    else:
        n = 1

    return fname_base+str(n)    



def parse_challoc(ch_alloc):
    """
    the channel allocation string must have one capital E,M,L (if present).
    If there are only lower-case e's, m's, or l's or only capital E's, M's, or L's,
    set the first e,m,l to upper-case and the rest to lower-case
    """
    
    # search for e's
    neeg = len(re.findall('[eE]', ch_alloc))
    nemg = len(re.findall('[mM]', ch_alloc))
    nlfp = len(re.findall('[lL]', ch_alloc))
    
    # only small e's
    if neeg == len(re.findall('e', ch_alloc)):
        ch_alloc = re.sub('e', 'E', ch_alloc, count=1)
    # only large E
    if neeg == len(re.findall('E', ch_alloc)):
        ch_alloc = re.sub('E', 'e', ch_alloc)
        ch_alloc = re.sub('e', 'E', ch_alloc, count=1)
    
    # only small m's
    if nemg == len(re.findall('m', ch_alloc)):
        ch_alloc = re.sub('m', 'M', ch_alloc, count=1)
    # only large M
    if nemg == len(re.findall('M', ch_alloc)):
        ch_alloc = re.sub('M', 'm', ch_alloc)
        ch_alloc = re.sub('m', 'M', ch_alloc, count=1)

    # only small l's
    if nlfp == len(re.findall('l', ch_alloc)):
        ch_alloc = re.sub('l', 'L', ch_alloc, count=1)
    # only large L
    if nlfp == len(re.findall('L', ch_alloc)):
        ch_alloc = re.sub('L', 'l', ch_alloc)
        ch_alloc = re.sub('l', 'L', ch_alloc, count=1)

    return ch_alloc



#######################################################################################  
### START OF SCRIPT ###################################################################
#######################################################################################
# Parameters to set at each computer:
PPATH = 'C:\\Users\\WeberChungPC_03\\Desktop\\intanCL_ctrl'
ndig = 16

# chose directory with intan raw files to be processed:
root = Tk.Tk()
intan_dir = tkf.askdirectory()
root.update()
# load all parameters from *.txt file, located in intan recording dir
param_file = get_param_file(intan_dir)

params = get_infoparam(intan_dir, param_file)
mice = params['mouse_ID']
print "We have here the following mice: %s" % (' '.join(mice))

# total number of recorded channels
ntotal_channels = sum([len(a) for a in params['ch_alloc']])
print('In total, %d channels were used' % ntotal_channels)
# get time stamp of recording
if params.has_key('date'):
    date = params['date'][0]  
    dtag = re.sub('/', '', date)
else:
    dtag = file_time(os.path.join(intan_dir, 'amplifier.dat'))
print "Using %s as date tag" % dtag

# load all data
print("Reading data file...")
data_amp = np.fromfile(os.path.join(intan_dir, 'amplifier.dat'), 'int16')
print("Processing digital inputs...")
data_din = np.fromfile(os.path.join(intan_dir, 'digitalin.dat'), 'int16')

# convert data_in to Array which each column corresponding to one digital input
#Din = np.fliplr(np.array([np.array(list(np.binary_repr(x, width=16))).astype('int16') for x in data_din]))
SR = int(params['SR'][0])
Din = np.zeros((data_din.shape[0], 16), dtype='int16')
ihour = 0
nhour = data_din.shape[0] / (3600 * SR)

dinmap = {}
for i in range(0, 2**ndig):
    dinmap[i] = np.array(list(np.binary_repr(i, width=ndig)[::-1])).astype('int16')

for j in range(data_din.shape[0]):
    if int(((j+1) % (3600*SR))) == 0:
        ihour += 1
        print "Done with %d out of %d hours" % (ihour, nhour)
    if data_din[j] >= 0:
        Din[j,:ndig] = dinmap[data_din[j]]
    else:
        Din[j,:ndig] = dinmap[0]

# consistency test: Number of data points in Din should match with data_amp:
if Din.shape[0] != data_amp.shape[0]/ntotal_channels:
    sys.exit('Something wrong: most likely some error in the channel allocation')

recording_list = []
# save data to individual mouse folders
imouse = 0
ch_offset = 0 # channel offset; 
for mouse in mice:
    print "Processing Mouse %s" % mouse
    ch_alloc = parse_challoc(params['ch_alloc'][imouse])
    nchannels = len(ch_alloc)
    fbase_name = mouse + '_' + dtag + 'n' 
    name = get_lowest_filenum(PPATH, fbase_name)
    recording_list.append(name)
    
    if not(os.path.isdir(os.path.join(PPATH,name))):
        print "Creating directory %s\n" % name
        os.mkdir(os.path.join(PPATH,name))        
    
    neeg = 1
    nemg = 1
    nlfp = 1
     # channel offset
    for c in ch_alloc:
        dfile = ''
        if re.match('E', c):
            dfile = 'EEG'
        if re.match('e', c):
            dfile = 'EEG' + str(neeg+1)
            neeg += 1
        if re.match('M', c):
            dfile = 'EMG'
        if re.match('m', c):
            dfile = 'EMG' + str(nemg+1)
            nemg += 1
        if re.match('L', c):
            dfile = 'LFP'
        if re.match('l', c):
            dfile = 'LFP' + (str(nlfp+1))
            nlfp += 1
        
        # Save EEG EMG
        if len(dfile) > 0:
            print "Saving %s of mouse %s" % (dfile, mouse)
            so.savemat(os.path.join(PPATH, name, dfile + '.mat'), {dfile: data_amp[ch_offset::ntotal_channels]})
        ch_offset += 1 # channel offset
        
    # save Laser
    so.savemat(os.path.join(PPATH, name, 'laser_' + name + '.mat'), {'laser':Din[:,1]})
    
    # save Video signal
    # Note: till 12/11/2017 I accidentally called the dictionary entry 'laser'
    so.savemat(os.path.join(PPATH, name, 'videotime_' + name + '.mat'), {'video':Din[:,2]})
    
    # save on/off signal (signal indicate when the recording started and ended)
    # only save first and last index, when signal is on
    onoff = np.where(Din[:,0]>0.1)[0][[0,-1]]
    so.savemat(os.path.join(PPATH, name, 'onoff_' + name + '.mat'), {'onoff':onoff})
    
    # save info file - I do this to split the parameter.txt file into
    # individual info.txt files for each recorded mouse
    fid = open(os.path.join(PPATH, name, 'info.txt'), 'w')    
    # first write notes
    comments = params['note'][mouse]
    for l in comments:
        fid.write(l + os.linesep)
    # write all other info tags
    for k in params.keys():
        v = params[k]
        if k == 'note':
            continue
        if len(v) == 1:
            # shared attribute
            fid.write(k + ':' + '\t' + v[0] + '\n')
        else:
            # individual attribute
            fid.write(k + ':' + '\t' + v[imouse] + '\n')
    # add a colleagues tag, i.e. other mice recorded together with mouse
    colleagues = mice[:]
    colleagues.remove(mouse)
    fid.write('colleagues:\t' + ' '.join(colleagues) + os.linesep)        
    fid.close()

    recursive_sleepstate_rem(PPATH, [name], psave=True)
    rmtree(os.path.join(PPATH, name))

    # copy info.rhd from intan_dir to PPATH/name
    # copy2(os.path.join(intan_dir, 'info.rhd'), os.path.join(PPATH, name))
    
    # end of loop over mice
    imouse += 1
    







